//! A crate for RISC-V PLIC inspired by Peripheral access API generated by svd2rust

#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]

use core::marker::PhantomData;
use core::ops::Deref;

#[allow(unused_imports)]
use generic::*;
/// Common register and bit access and modify traits
pub mod generic;

/// RISC-V Platform-Level Interrupt Controller
pub mod plic;

/// RISC-V Platform-Level Interrupt Controller
///
/// ```no_run
/// # use rv_plic::*;
/// pub const PLIC_BASE: usize = 0xc00_0000;
/// type plic = PLIC<PLIC_BASE>;
/// plic.context[1].threshold.write(0x1);
/// plic.enable_c[1].enable_s[0].write(1 << 10);
/// plic.priority[10].write(0x1);
/// ```
pub struct PLIC<const BASE: usize> {
    _marker: PhantomData<*const ()>,
}

unsafe impl<const BASE: usize> Send for PLIC<BASE> {}

impl<const BASE: usize> Deref for PLIC<BASE> {
    type Target = plic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::ptr() }
    }
}

impl<const BASE: usize> core::fmt::Debug for PLIC<BASE> {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PLIC").finish()
    }
}

impl<const BASE: usize> PLIC<BASE> {
    /// Pointer to the register block
    pub const PTR: *const plic::RegisterBlock = BASE as *const _;

    /// Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const plic::RegisterBlock {
        Self::PTR
    }

    /// Check if interrupt `i` is enabled on context `c`
    pub fn is_enabled(&self, context: usize, interrupt: u16) -> bool {
        self.enable_c[context].enable_s[(interrupt / 32) as usize]
            .read()
            .bits()
            & 1 << (interrupt % 32)
            != 0
    }

    /// Enable interrupt `i` for context `c`
    pub fn enable(&self, context: usize, interrupt: u16) {
        self.enable_c[context].enable_s[(interrupt / 32) as usize]
            .modify(|r, w| unsafe { w.bits(r.bits | 1 << (interrupt % 32)) });
    }

    /// Disable interrupt `i` for context `c`
    pub fn disable(&self, context: usize, interrupt: u16) {
        self.enable_c[context].enable_s[(interrupt / 32) as usize]
            .modify(|r, w| unsafe { w.bits(r.bits & !(1 << (interrupt % 32))) });
    }

    /// Get the priority of interrupt `i`
    pub fn get_priority(&self, interrupt: u16) -> u32 {
        self.priority[interrupt as usize].read().bits()
    }

    /// Set the priority of interrupt `i`
    pub fn set_priority(&self, interrupt: u16, priority: u32) {
        self.priority[interrupt as usize].write(|w| unsafe { w.bits(priority) });
    }

    /// Get the threshold of context `c`
    pub fn get_threshold(&self, context: usize) -> u32 {
        self.context[context].threshold.read().bits()
    }

    /// Set the threshold of context `c`
    pub fn set_threshold(&self, context: usize, threshold: u32) {
        self.context[context]
            .threshold
            .write(|w| unsafe { w.bits(threshold) });
    }

    /// Check if interrupt `i` is pending
    pub fn is_pending(&self, interrupt: u16) -> bool {
        self.pending[(interrupt / 32) as usize].read().bits() & 1 << (interrupt % 32) != 0
    }

    /// Claim interrupt on context `c`
    pub fn claim(&self, context: usize) -> Option<u16> {
        let irq = self.context[context].claim_complete.read().bits();
        match irq {
            0 => None,
            _ => Some(irq as u16),
        }
    }

    /// Complete interrupt `i` on context `c`
    pub fn complete(&self, context: usize, interrupt: u16) {
        self.context[context]
            .claim_complete
            .write(|w| unsafe { w.bits(interrupt as u32) });
    }
}
